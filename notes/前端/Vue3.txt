# 项目构建

```bash
npm create vue@latest
```

# Vue 组件的基本结构

```vue
<template>
</template>
<script setup lang="ts">
</script>
<style scoped>
</style>
```

# 其他知识

本章放一些杂七杂八的知识点。由于学习过程中难免会有知识穿插，为了统一管理，均放在此处。

## 配置 `npm run` 在 `0.0.0.0`

### 1. Vite（最常见）

如果你在使用 Vite，可以通过修改 `vite.config.js` 或 `vite.config.ts` 文件来实现。

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  plugins: [vue()],
  server: {
    host: '0.0.0.0', // 设置为 0.0.0.0 即可
    port: 5173,      // 可选，设置端口
  },
});
```

## nanoid

可以随机生成一个唯一 ID。

```bash
npm i nanoid
```

```vue
<script setup lang="ts">
import { nanoid } from "nanoid";
let id = nanoid();
</script>
```

## defineExpose

这个函数通常放在组件的最后面，用来定义对外暴露的属性。

例如：

在 `Person` 组件中：

```vue
<script setup lang="ts">
import { ref } from 'vue';
let testText = '会有人发现我吗？';
</script>
```

在 `App` 组件中访问 `Person` 实例：

```vue
<template>
  <Person ref="ren" />
</template>
<script setup lang="ts">
import Person from './components/Person.vue';
import { ref } from 'vue';

let ren = ref();
console.log(ren);
</script>
```

得到的结果是：（此处原图路径无效，建议替换为有效路径或删除）

将 `testText` 暴露：

```vue
<script setup lang="ts">
import { defineExpose, ref } from 'vue';
let testText = '会有人发现我吗？';
defineExpose({ testText });
</script>
```

## axios

1. 网络请求库  
2. 同一套代码可运行在 Node.js 或浏览器中  
3. 发起一个 GET 请求  
4. 发起一个 POST 请求  

`axios` 是一个网络请求库，一套代码可以运行在浏览器或 Node.js 上。可以安装 `vue-axios` 以在 Vue 中使用。

```bash
npm install vue-axios
```

发起一个 GET 请求示例：

```ts
let picture = ref('');
function getPicture() {
  axios.get("https://dog.ceo/api/breed/pembroke/images/random")
    .then((response) => {
      picture.value = response.data.message;
    })
    .catch(() => {
      alert('获取图片异常');
    });
}
```

GET 请求传递参数可以直接写在 URL 里，也可以以对象形式作为 `get` 方法的第二个参数。

下面是 `async/await` 写法：

```ts
async function getPicture() {
  try {
    const response = await axios.get("https://dog.ceo/api/breed/pembroke/images/random");
    picture.value = response.data.message;
  } catch (error) {
    alert('图片获取失败');
  }
}
```

> **注意**：这里点到为止，后续需要对 `axios` 进行更详细的学习。

# setup

组合式 API 可以用 `<script setup>` 来避免每次书写 `setup` 函数。  
在 `<script setup>` 标签中，无需将定义的数据返回就可以在 `<template>` 标签中访问到。

# ref / reactive

- `ref`：可以定义响应式基本数据，也可以定义响应式对象，但其定义的响应式对象是**浅层**的。
- `reactive`：只可以定义响应式对象，其定义的响应式对象是**深层**的。

`reactive` 有一个弊端：无法直接将整个对象替换为另一个对象。即使重新生成一个 `reactive` 对象，页面也不会更新，因为新对象已不是原来绑定的那个。

如果确实需要整体替换，可以使用：

```js
Object.assign(oldObject, newObject);
```

> **注意**：`ref` 定义的变量在模板字符串中可以直接使用，无需 `.value`。

## 使用 ref 获取 DOM

在 Vue 中，不应使用 `document` 获取 HTML 元素，而应声明一个 `ref` 变量，并将其绑定到元素的 `ref` 属性上：

```vue
<template>
  <div ref="tkytest"></div>
</template>
<script setup>
import { ref } from "vue";
const tkytest = ref();
</script>
```

此时 `tkytest.value` 就是该 `div` 元素的 DOM 节点。

# toRef / toRefs

对于响应式数据，直接解构会失去响应性。可使用 `toRef` 或 `toRefs` 保持响应性。

- `toRef`：一次只能解构一个属性  
- `toRefs`：可一次性解构所有属性

示例模板：

```vue
<template>
  <h1>name: {{ name }}</h1>
  <h1>age: {{ age }}</h1>
</template>
```

使用 `toRef`：

```vue
<script setup lang="ts">
import { reactive, toRef } from 'vue';
let Person = reactive({ name: 'san zhang', age: 25 });
let name = toRef(Person, 'name');
let age = toRef(Person, 'age');
</script>
```

使用 `toRefs`：

```vue
<script setup lang="ts">
import { reactive, toRefs } from 'vue';
let Person = reactive({ name: 'san zhang', age: 25 });
let { name, age } = toRefs(Person);
</script>
```

# v-model

结合输入框，可以让响应式变量与输入框内容保持一致。  
`v-model.number` 可以设定绑定值的类型为数字。

# computed 计算属性

- 方法没有缓存，计算属性有缓存。
- `computed` 传入一个函数，返回值是一个 `ComputedRef`，访问时需使用 `.value`。
- 有两种写法：只读、可读可写。

模板示例：

```vue
<template>
  <input v-model="firstname"><br>
  <input v-model="lastname"><br>
  <span>全名计算器: {{ fullname }}</span>
</template>
```

只读写法：

```vue
<script setup lang="ts">
import { ref, computed } from 'vue';
let firstname = ref('zhang');
let lastname = ref('san');
let fullname = computed(() => {
  return firstname.value.slice(0, 1).toUpperCase() + firstname.value.slice(1) + ' ' + lastname.value;
});
</script>
```

可读可写写法（通过 `get` / `set`）：

```vue
<template>
  <input v-model="firstname"><br>
  <input v-model="lastname"><br>
  <span>全名计算器: {{ fullname }}</span><br>
  <button @click="changeFullName">修改 fullname</button>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';

let firstname = ref('zhang');
let lastname = ref('san');

let fullname = computed({
  get() {
    return firstname.value.slice(0, 1).toUpperCase() + firstname.value.slice(1) + ' ' + lastname.value;
  },
  set(value) {
    let [tempfirst, templast] = value.split(' ');
    firstname.value = tempfirst;
    lastname.value = templast;
  }
});

function changeFullName() {
  fullname.value = "Tian kaiyuan";
}
</script>
```

# watch

`watch` 用于监视响应式数据的变化。

- 第一个参数：监视目标（4 种类型）
  1. `ref`
  2. `reactive`
  3. 返回值的函数（getter）
  4. 上述内容组成的数组
- 第二个参数：回调函数 `(newValue, oldValue) => {}`
- 第三个参数：配置对象（如 `{ deep: true, immediate: true }`）
- 返回值：一个函数，调用后可停止监听

## watch - 情况一

监视 `ref` 基本类型：

```vue
<template>
  <span>{{ sum }}</span><br>
  <input v-model="input">
  <button @click="changeSum">修改</button>
</template>

<script setup lang="ts">
import { ref, watch } from 'vue';

let sum = ref(1);
let input = ref('');

const stopwatch = watch(sum, (newValue, oldValue) => {
  if (newValue > 2 * oldValue) {
    alert("this is an alert");
  }
});

function changeSum() {
  if (input.value) {
    sum.value = parseInt(input.value);
  }
}
</script>
```

> 注意：若监视 `reactive` 对象本身（非属性），则只监听对象引用变化，不监听内部属性变化。

## watch - 情况二

监视 `reactive` 对象的**内部属性变化**，需设置 `{ deep: true }`：

```ts
const stopwatch = watch(Person, (newValue, oldValue) => {
  console.log(Person, newValue, oldValue);
}, { deep: true });
```

> 注意：此时 `newValue` 和 `oldValue` 是同一个对象（因为是同一个引用），均为最新值。

> **提示**：配置 `immediate: true` 可在初始化时立即执行一次回调。

## watch - 情况三

监视 `reactive` 对象时，默认**深度监听**，且**无法关闭**。  
但不能整体替换对象（`reactive` 不支持），只能通过 `Object.assign` 修改属性。

## watch - 情况四

若只想监听对象中的**某个属性**，应传入一个返回该属性的函数（getter）：

```ts
watch(() => Person.name, (newName, oldName) => {
  console.log('name changed:', newName);
});
```

> 建议始终使用函数形式，避免监听失效。

## watch - 情况五

监听多个数据：传入数组

```ts
watch([ref1, () => obj.prop], ([new1, new2], [old1, old2]) => {
  // ...
});
```

## watchEffect

自动追踪依赖，无需显式指定监听目标。

```vue
<template>
  <h1>水温：{{ temp }}</h1><br>
  <h1>水位：{{ height }}</h1><br>
  <button @click="changeTemp">增加温度</button><br>
  <button @click="changeHeight">增加水位</button>
</template>

<script setup lang="ts">
import { watchEffect, ref } from 'vue';

let temp = ref(0);
let height = ref(0);

function changeTemp() {
  temp.value += 1;
}
function changeHeight() {
  height.value += 1;
}

watchEffect(() => {
  if (temp.value > 10 && height.value > 10) {
    alert('可以了可以了');
  }
});
</script>
```

# Vue 编译为单页应用（SPA）常见问题解决方案

## 1. 局部样式

全局样式会影响所有组件。应使用 `<style scoped>` 实现局部样式：

```vue
<style scoped>
/* 样式仅作用于当前组件 */
</style>
```

## 2. 使用 `ref` 而不是 `id`

多个组件使用相同 `id` 会导致冲突。应使用 `ref` 获取元素。

# defineProps

用于父组件向子组件传递参数。

父组件：

```vue
<!-- App.vue -->
<template>
  <Person msg="This is a message" />
</template>
```

子组件接收（字面量）：

```vue
<!-- Person.vue -->
<script setup lang="ts">
defineProps(['msg']);
</script>
<template>
  <div>{{ msg }}</div>
</template>
```

传递响应式数据（使用 `v-bind` 或 `:`）：

```vue
<!-- App.vue -->
<template>
  <Person :msg="personlist" />
</template>
```

```vue
<!-- Person.vue -->
<template>
  <ul>
    <li v-for="item in msg">{{ item.name }} - {{ item.age }}</li>
  </ul>
</template>
```

### 类型安全（TypeScript）

```ts
<script setup lang="ts">
import { defineProps } from 'vue';
import type { persons } from '@/types/index';

defineProps<{ list: persons }>();
</script>
```

可选参数（加 `?`）：

```ts
defineProps<{ list?: persons }>();
```

设置默认值（使用 `withDefaults`）：

```ts
withDefaults(defineProps<{ list?: persons }>(), {
  list: () => [{ name: 'tiankaiyuan', age: 23 }]
});
```

> **注意**：默认值对象中的属性值应为**函数**。

# 生命周期

| 阶段     | 钩子函数                     |
|----------|------------------------------|
| 创建阶段 | `setup`                      |
| 挂载阶段 | `onBeforeMount`, `onMounted` |
| 更新阶段 | `onBeforeUpdate`, `onUpdated`|
| 卸载阶段 | `onBeforeUnmount`, `onUnmounted` |

> Vue 3 的创建过程是“深度优先搜索”，子组件挂载早于父组件。

# 自定义 Hooks

将逻辑封装到 `useXXX.ts` 文件中：

```ts
// usePerson.ts
import { ref } from "vue";

export default function() {
  let sum = ref(0);
  function add() {
    sum.value += 1;
  }
  return { sum, add };
}
```

使用：

```vue
<script setup lang="ts">
import usePerson from '@/hooks/usePerson';
const { sum, add } = usePerson();
</script>
<template>
  <h1>{{ sum }}</h1>
  <button @click="add">加一</button>
</template>
```

# 路由

> 一般组件放 `components/`，路由组件放 `pages/` 或 `views/`。

## 基本页面切换

安装：

```bash
npm install vue-router
```

创建路由（`src/router/index.ts`）：

```ts
import { createRouter, createWebHistory } from "vue-router";
import MainHtml from "@/components/MainHtml.vue";
import HelloWorld from "@/components/HelloWorld.vue";
import Picture from "@/components/Picture.vue";

const router = createRouter({
  history: createWebHistory(),
  routes: [
    { path: '/', component: MainHtml },
    { path: '/picture', component: Picture },
    { path: '/about', component: HelloWorld }
  ],
});

export default router;
```

在 `main.ts` 中使用：

```ts
import { createApp } from 'vue';
import App from './App.vue';
import router from "@/router/index";

const app = createApp(App);
app.use(router);
app.mount("#app"); // 必须在所有 use 之后
```

在 App 中使用路由组件：

```vue
<template>
  <div>
    <h1>路由测试</h1>
    <div class="navigation">
      <RouterLink to="/" class="tky">首页</RouterLink>
      <RouterLink to="/picture" class="tky">狗狗图片</RouterLink>
      <RouterLink to="/about" class="tky">关于</RouterLink>
    </div>
    <RouterView />
  </div>
</template>
```

## 路由器工作模式

- `createWebHistory()`：history 模式，URL 无 `#`，需后端支持
- `createWebHashHistory()`：hash 模式，URL 含 `#`，无需后端配置，但 SEO 较差

## 命名路由

```ts
{ name: 'dogs', path: '/picture', component: Picture }
```

使用：

```vue
<RouterLink :to="{ name: 'dogs' }">狗狗图片</RouterLink>
```

## 路由嵌套

```ts
{
  path: '/about',
  component: HelloWorld,
  children: [
    { path: 'tky', component: tkyView }
  ]
}
```

> 子路由 `path` 不加 `/`。

## 路由传参

### query 传参

```vue
<RouterLink :to="`/about/tky?message=${msg}`">tky</RouterLink>
```

或：

```vue
<RouterLink :to="{ path: '/about/tky', query: { msg: 'hello' } }">tky</RouterLink>
```

接收：

```ts
import { useRoute } from 'vue-router';
import { toRef } from 'vue';

const route = useRoute();
const query = toRef(route, 'query');
```

### params 传参

路由定义需占位：

```ts
{ name: 'dogs', path: '/picture/:id/:msg', component: Picture }
```

跳转时：

```vue
<RouterLink :to="{ name: 'dogs', params: { id: 1, msg: 'hi' } }">Go</RouterLink>
```

> 使用 `params` 时，若用对象形式，**不能用 `path`，必须用 `name`**。

### 路由的 props 配置

简化参数获取：

```ts
{
  path: 'tky',
  component: tkyView,
  props(route) {
    return route.query;
  }
}
```

组件中直接用 `defineProps`：

```vue
<script setup lang="ts">
defineProps(['msg']);
</script>
```

## 路由的 replace 属性

```vue
<RouterLink replace to="/home">Home</RouterLink>
```

> `replace` 不会留下历史记录，无法通过浏览器“返回”按钮回到上一页。

## 编程式导航

```ts
import { useRouter } from 'vue-router';

const router = useRouter();
router.push('/home');
router.replace({ name: 'dogs' });
```

返回按钮示例：

```vue
<template>
  <button @click="backPage">返回</button>
</template>
<script setup lang="ts">
import { useRouter } from 'vue-router';
const router = useRouter();
function backPage() {
  router.push('/');
}
</script>
```

## 路由重定向

```ts
{ path: '/', redirect: '/picture' }
```

# Pinia

集中式状态管理。

## 安装与使用

```bash
npm i pinia
```

`main.ts`：

```ts
import { createPinia } from "pinia";
const pinia = createPinia();
app.use(pinia);
```

## Store 定义（选项式）

`src/store/count.ts`：

```ts
import { defineStore } from "pinia";

export const useCountStore = defineStore('count', {
  state() {
    return {
      sum: 0,
      name: "tiankaiyuan",
      job: "software engineer"
    };
  },
  actions: {
    add(value: number) {
      this.sum += value;
    }
  },
  getters: {
    tkytest: (state) => state.name + '-' + state.job
  }
});
```

使用：

```vue
<script setup lang="ts">
import { useCountStore } from "@/store/count";
const countStore = useCountStore();
</script>
```

批量修改：

```ts
countStore.$patch({
  sum: 666,
  name: 'nottky',
  job: 'reader'
});
```

## storeToRefs

避免 `toRefs` 包裹方法，只解构状态：

```ts
import { storeToRefs } from 'pinia';
const { sum, name } = storeToRefs(useCountStore());
```

## 组合式写法（推荐）

```ts
export const useCountStore = defineStore('count', () => {
  const sum = ref(0);
  const name = ref("tiankaiyuan");
  const job = ref("software engineer");
  const tkytest = computed(() => name.value + '-' + job.value);

  function add(value: number) {
    sum.value += value;
  }

  return { sum, name, job, tkytest, add };
});
```

# 组件通信

## props（父传子）

见前文 `defineProps`。

## 子传父（通过函数 props）

父：

```vue
<template>
  <h1>{{ tky }}</h1>
  <Child :car="car" :tkytest="getTky" />
</template>
<script setup lang="ts">
import Child from './Child.vue';
import { ref } from 'vue';

let tky = ref('');
function getTky(value: string) {
  tky.value = value;
}
</script>
```

子：

```vue
<template>
  <button @click="tkytest(msg)">你是不是神经病</button>
</template>
<script setup lang="ts">
import { ref } from 'vue';
let msg = ref('你咋知道');
defineProps(['tkytest']);
</script>
```

## 自定义事件（推荐）

父：

```vue
<template>
  <Child @tky="tkyEvent" />
</template>
<script setup lang="ts">
import Child from './Child.vue';
import { ref } from "vue";

let msg = ref('');
function tkyEvent(value: string) {
  msg.value = value;
}
</script>
```

子：

```vue
<template>
  <button @click="tkyButton">你是我爸爸吗</button>
</template>
<script setup lang="ts">
const emit = defineEmits(["tky"]);
function tkyButton() {
  emit("tky", '你咋知道');
}
</script>
```

> 事件名建议使用 kebab-case（如 `update:value`）。

## mitt（任意组件通信）

安装：

```bash
npm install mitt
```

`utils/emitter.ts`：

```ts
import mitt from 'mitt';
const emitter = mitt();
export default emitter;
```

Child1：

```vue
<template>
  <div class="child1">
    <h1>{{ text }}</h1>
    <input v-model="msg">
    <button @click="emitter.emit('child2Get', msg)">Send</button>
  </div>
</template>
<script setup lang="ts">
import { ref, onUnmounted } from 'vue';
import emitter from '@/utils/emitter';

const text = ref('');
const msg = ref('');

emitter.on("child1Get", (yourMsg) => {
  text.value = yourMsg;
});

onUnmounted(() => {
  emitter.off("child1Get");
});
</script>
```

Child2 类似，监听 `child2Get`，发送 `child1Get`。

## v-model（父子双向绑定）

父：

```vue
<template>
  <h1>{{ tkydata }}</h1>
  <ChildComponent v-model:tkydata="tkydata" />
</template>
<script setup lang="ts">
import { ref } from "vue";
const tkydata = ref("让我自己先来写一个数据");
</script>
```

子：

```vue
<template>
  <input
    type="text"
    :value="tkydata"
    @input="emit('update:tkydata', ($event.target as HTMLInputElement).value)"
  />
</template>
<script setup lang="ts">
defineProps(["tkydata"]);
const emit = defineEmits(["update:tkydata"]);
</script>
```

> `$event` 在原生 HTML 中是事件对象，需用 `.target`；在自定义组件中是传递的数据。

## attrs（隔代传递）

父传 `a, b, c, d`，子只接收 `a`，则 `b, c, d` 在 `$attrs` 中。

子可透传给孙子：

```vue
<template>
  <grandchild v-bind="$attrs" />
</template>
<script setup>
defineProps(['a']);
</script>
```

## $refs / $parent

父通过 `ref` 获取子组件实例（需子组件 `defineExpose`）：

```vue
<!-- Father -->
<script setup>
import { ref } from "vue";
const c1 = ref();
function buttonFunction() {
  console.log(c1.value.toy); // 子暴露的 toy
}
</script>
<template>
  <Child1 ref="c1" />
</template>
```

```vue
<!-- Child1 -->
<script setup>
import { ref } from "vue";
const toy = ref('Paperpass');
defineExpose({ toy });
</script>
```

> `$parent` 可反向访问父组件（不推荐，破坏封装）。

## provide / inject（祖孙通信）

祖父：

```ts
import { provide, ref } from "vue";
const coins = ref(100);
provide("coins", {
  value: coins,
  takeOff: () => { coins.value -= 10; }
});
```

孙子：

```ts
import { inject } from "vue";
const coins = inject('coins', { value: 0, takeOff: () => {} });
```

> 可传递响应式数据和方法。

# 插槽（Slot）

## 默认插槽

子组件：

```vue
<template>
  <div>
    <h1>{{ title }}</h1>
    <slot></slot>
  </div>
</template>
<script setup>
defineProps(["title"]);
</script>
```

父组件：

```vue
<Child title="Game">
  <span>{{ gameName }}</span>
</Child>
```

## 具名插槽

子：

```vue
<template>
  <slot name="title"></slot>
  <slot name="content"></slot>
</template>
```

父：

```vue
<Child>
  <template #title>Game</template>
  <template #content>{{ gameName }}</template>
</Child>
```

> `#name` 是 `v-slot:name` 的简写。

## 作用域插槽（子传数据给父）

子：

```vue
<slot name="content" :data="list"></slot>
```

父：

```vue
<template #content="slotProps">
  <ul>
    <li v-for="item in slotProps.data">{{ item }}</li>
  </ul>
</template>
```

> `slotProps` 可任意命名。

# 其他 API

## shallowRef / shallowReactive

仅第一层响应。

## readonly / shallowReadonly

创建只读代理。

## toRaw / markRaw

- `toRaw`：获取原始对象（慎用）
- `markRaw`：标记对象永不转为响应式

## customRef

自定义响应逻辑（如防抖）：

```ts
// hooks/useTkyRef.ts
import { customRef } from "vue";

export default function(initValue: string) {
  let rowData = initValue;
  let timer: number;

  return customRef((track, trigger) => ({
    get() {
      track();
      return rowData;
    },
    set(value) {
      clearTimeout(timer);
      timer = setTimeout(() => {
        rowData = value;
        trigger();
      }, 2000);
    }
  }));
}
```

## Teleport

将组件渲染到 DOM 树其他位置（如 `body`）：

```vue
<Teleport to="body">
  <div class="modal">...</div>
</Teleport>
```

# CSS

（此处 CSS 内容格式良好，仅微调标题层级和代码块语言标识）

## 选择器

### 一、基础选择器 (Basic Selectors)

- **通用选择器 (`*`)**  
- **标签选择器 (`p`)**  
- **类选择器 (`.my-class`)**  
- **ID 选择器 (`#my-id`)**

### 二、组合选择器 (Combinators)

- 后代：`div p`
- 子代：`div > p`
- 相邻兄弟：`div + p`
- 通用兄弟：`div ~ p`

### 三、属性选择器

- `[attr]`
- `[attr="val"]`
- `[attr^="val"]`
- `[attr$="val"]`
- `[attr*="val"]`

### 四、伪类与伪元素

- 伪类：`:hover`, `:nth-child(n)`
- 伪元素：`::before`, `::after`

### CSS 优先级 (Specificity)

计算：`(a, b, c, d)`  
- a: 内联样式  
- b: ID 数量  
- c: 类/属性/伪类数量  
- d: 标签/伪元素数量  

`!important` 优先级最高（慎用）。

## Flexbox

### 核心概念

- Flex 容器：`display: flex`
- Flex 项目：直接子元素
- 主轴 / 交叉轴

### 容器属性

- `flex-direction`: `row` / `column`
- `flex-wrap`: `nowrap` / `wrap`
- `justify-content`: 主轴对齐
- `align-items`: 交叉轴对齐
- `flex-flow`: 简写

### 项目属性

- `flex-grow` / `flex-shrink` / `flex-basis`
- `flex`: 简写（`flex: 1` 常用）
- `align-self`: 单个项目对齐
- `order`: 排序

### 常见技巧

- 水平垂直居中：
  ```css
  .container {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  ```
