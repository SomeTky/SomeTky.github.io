# ORDER BY排序功能实现方案

基于你已完成的词法分析和语法分析工作，要实现对SELECT语句结果的排序功能，确实需要创建新的算子并在stmt中添加相关支持。下面是详细的实现方案：

## 一、数据结构准备

### 1. 首先在SelectStmt中添加ORDER BY相关字段

```cpp
class SelectStmt : public Stmt
{
public:
    // ... 现有代码 ...
    
    // 添加ORDER BY相关方法
    void add_order_by(unique_ptr<Expression> expr, bool is_asc);
    const vector<pair<unique_ptr<Expression>, bool>> &order_by_exprs() const;
    
private:
    // ... 现有代码 ...
    
    // 添加ORDER BY字段
    vector<pair<unique_ptr<Expression>, bool>> order_by_exprs_; // 排序表达式和是否升序
};
```

### 2. 在SelectSqlNode中添加ORDER BY字段

```cpp
struct SelectSqlNode
{
    // ... 现有代码 ...
    
    // 添加ORDER BY字段
    vector<pair<Expression *, bool>> order_by_exprs; // 排序表达式和是否升序
};
```

## 二、实现排序逻辑算子

### 1. 在LogicalOperatorType中添加SORT类型

```cpp
enum class LogicalOperatorType
{
    // ... 现有代码 ...
    SORT,    ///< 排序
};
```

### 2. 创建SortLogicalOperator类

```cpp
#pragma once

#include "sql/operator/logical_operator.h"

/**
 * @brief 排序逻辑算子
 * @ingroup LogicalOperator
 */
class SortLogicalOperator : public LogicalOperator
{
public:
    SortLogicalOperator(vector<pair<unique_ptr<Expression>, bool>> &&order_by_exprs)
        : order_by_exprs_(std::move(order_by_exprs))
    {}

    virtual ~SortLogicalOperator() = default;

    LogicalOperatorType type() const override { return LogicalOperatorType::SORT; }
    
    const vector<pair<unique_ptr<Expression>, bool>> &order_by_exprs() const { return order_by_exprs_; }
    
private:
    vector<pair<unique_ptr<Expression>, bool>> order_by_exprs_; // 排序表达式和是否升序
};
```

## 三、实现排序物理算子

### 1. 在PhysicalOperatorType中添加SORT类型

```cpp
enum class PhysicalOperatorType
{
    // ... 现有代码 ...
    SORT,    ///< 排序
};
```

### 2. 创建SortPhysicalOperator类

```cpp
#pragma once

#include "sql/operator/physical_operator.h"

/**
 * @brief 排序物理算子
 * @ingroup PhysicalOperator
 */
class SortPhysicalOperator : public PhysicalOperator
{
public:
    SortPhysicalOperator(vector<pair<unique_ptr<Expression>, bool>> &&order_by_exprs);

    virtual ~SortPhysicalOperator() = default;

    PhysicalOperatorType type() const override { return PhysicalOperatorType::SORT; }
    
    RC open(Trx *trx) override;
    RC next() override;
    RC close() override;
    
    Tuple *current_tuple() override;

private:
    RC sort_tuples();
    bool compare_tuples(const Tuple &left, const Tuple &right) const;
    
private:
    Trx *trx_ = nullptr;
    vector<pair<unique_ptr<Expression>, bool>> order_by_exprs_;
    vector<unique_ptr<Tuple>> sorted_tuples_;
    vector<unique_ptr<Tuple>>::iterator current_iterator_;
    bool sorted_ = false;
};
```

### 3. 实现SortPhysicalOperator的方法

```cpp
#include "sql/operator/sort_physical_operator.h"
#include "common/log/log.h"

SortPhysicalOperator::SortPhysicalOperator(vector<pair<unique_ptr<Expression>, bool>> &&order_by_exprs)
    : order_by_exprs_(std::move(order_by_exprs))
{}

RC SortPhysicalOperator::open(Trx *trx)
{
    trx_ = trx;
    
    if (children_.empty()) {
        return RC::SUCCESS;
    }
    
    PhysicalOperator *child = children_[0].get();
    RC rc = child->open(trx);
    if (OB_FAIL(rc)) {
        LOG_WARN("failed to open child operator. rc=%s", strrc(rc));
        return rc;
    }
    
    return RC::SUCCESS;
}

RC SortPhysicalOperator::next()
{
    if (!sorted_) {
        RC rc = sort_tuples();
        if (OB_FAIL(rc)) {
            return rc;
        }
        sorted_ = true;
        current_iterator_ = sorted_tuples_.begin();
    }
    
    if (current_iterator_ == sorted_tuples_.end()) {
        return RC::RECORD_EOF;
    }
    
    current_iterator_++;
    return RC::SUCCESS;
}

RC SortPhysicalOperator::close()
{
    if (!children_.empty()) {
        children_[0]->close();
    }
    sorted_tuples_.clear();
    sorted_ = false;
    return RC::SUCCESS;
}

Tuple *SortPhysicalOperator::current_tuple()
{
    if (current_iterator_ == sorted_tuples_.begin()) {
        return nullptr;
    }
    
    return std::prev(current_iterator_).get();
}

RC SortPhysicalOperator::sort_tuples()
{
    PhysicalOperator *child = children_[0].get();
    
    // 收集所有元组
    while (true) {
        RC rc = child->next();
        if (rc == RC::RECORD_EOF) {
            break;
        }
        if (OB_FAIL(rc)) {
            LOG_WARN("failed to get next tuple. rc=%s", strrc(rc));
            return rc;
        }
        
        Tuple *tuple = child->current_tuple();
        if (tuple) {
            // 复制元组到排序缓冲区
            sorted_tuples_.push_back(tuple->clone());
        }
    }
    
    // 对元组进行排序
    std::sort(sorted_tuples_.begin(), sorted_tuples_.end(), [this](const unique_ptr<Tuple> &left, const unique_ptr<Tuple> &right) {
        return compare_tuples(*left, *right);
    });
    
    return RC::SUCCESS;
}

bool SortPhysicalOperator::compare_tuples(const Tuple &left, const Tuple &right) const
{
    for (const auto &[expr, is_asc] : order_by_exprs_) {
        Value left_value, right_value;
        
        RC rc_left = expr->eval(left, left_value);
        RC rc_right = expr->eval(right, right_value);
        
        if (OB_FAIL(rc_left) || OB_FAIL(rc_right)) {
            return false; // 出错时返回默认顺序
        }
        
        int compare_result = left_value.compare(right_value);
        if (compare_result != 0) {
            return is_asc ? (compare_result < 0) : (compare_result > 0);
        }
    }
    
    return false; // 所有排序键都相等时，保持原顺序
}
```

## 四、在逻辑计划生成器中添加ORDER BY处理

### 1. 在LogicalPlanGenerator中添加对SORT的支持

```cpp
RC LogicalPlanGenerator::create_plan(SelectStmt *select_stmt, unique_ptr<LogicalOperator> &logical_operator)
{
    // ... 现有代码 ...
    
    // 如果有ORDER BY子句，创建SORT逻辑算子
    if (!select_stmt->order_by_exprs().empty()) {
        auto sort_oper = make_unique<SortLogicalOperator>(std::move(create_order_by_exprs(select_stmt->order_by_exprs())));
        sort_oper->add_child(std::move(logical_operator));
        logical_operator = std::move(sort_oper);
    }
    
    return RC::SUCCESS;
}

vector<pair<unique_ptr<Expression>, bool>> LogicalPlanGenerator::create_order_by_exprs(
    const vector<pair<unique_ptr<Expression>, bool>> &order_by_exprs)
{
    vector<pair<unique_ptr<Expression>, bool>> exprs;
    for (const auto &[expr, is_asc] : order_by_exprs) {
        exprs.emplace_back(expr->clone(), is_asc);
    }
    return exprs;
}
```

## 五、在物理计划生成器中添加ORDER BY支持

### 1. 在PhysicalPlanGenerator中添加对SORT的支持

```cpp
RC PhysicalPlanGenerator::create(LogicalOperator &logical_operator, unique_ptr<PhysicalOperator> &oper, Session* session)
{
    RC rc = RC::SUCCESS;

    switch (logical_operator.type()) {
        // ... 现有代码 ...
        
        case LogicalOperatorType::SORT: {
            return create_plan(static_cast<SortLogicalOperator &>(logical_operator), oper, session);
        } break;
        
        // ... 现有代码 ...
    }
    return rc;
}

RC PhysicalPlanGenerator::create_plan(SortLogicalOperator &sort_oper, unique_ptr<PhysicalOperator> &oper, Session* session)
{
    RC rc = RC::SUCCESS;
    
    // 创建排序物理算子
    vector<pair<unique_ptr<Expression>, bool>> order_by_exprs;
    for (const auto &[expr, is_asc] : sort_oper.order_by_exprs()) {
        order_by_exprs.emplace_back(expr->clone(), is_asc);
    }
    
    auto sort_physical_oper = make_unique<SortPhysicalOperator>(std::move(order_by_exprs));
    
    // 处理子算子
    ASSERT(sort_oper.children().size() == 1, "sort operator should have 1 child");
    
    LogicalOperator &child_logical_oper = *sort_oper.children().front();
    unique_ptr<PhysicalOperator> child_physical_oper;
    rc = create(child_logical_oper, child_physical_oper, session);
    if (OB_FAIL(rc)) {
        LOG_WARN("failed to create child physical operator of sort operator. rc=%s", strrc(rc));
        return rc;
    }
    
    sort_physical_oper->add_child(std::move(child_physical_oper));
    oper = std::move(sort_physical_oper);
    
    return RC::SUCCESS;
}
```

## 实现说明

1. **整体架构**：通过添加排序逻辑算子和物理算子，将排序功能集成到现有执行计划框架中

2. **数据处理流程**：
   - SortPhysicalOperator会先收集所有子算子产生的元组
   - 将元组按照指定的排序表达式和顺序进行排序
   - 然后依次返回排序后的元组

3. **优化考量**：
   - 目前实现是内存排序，适用于小数据集
   - 对于大数据集，可以考虑实现外部排序算法
   - 可以添加对索引排序的利用，避免额外排序操作

4. **扩展点**：
   - 支持多列排序
   - 支持NULL值的排序规则
   - 支持COLLATE子句指定排序规则

这个实现方案遵循了miniob项目现有的算子设计模式，与其他算子的实现方式保持一致，便于集成和维护。
        