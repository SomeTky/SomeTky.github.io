`yield` 是 Python 中一个非常强大但初学者容易困惑的关键字。它的核心作用是**将一个普通函数变成“生成器函数”（generator function）**，用于**惰性求值（lazy evaluation）**和**节省内存**。

---

## 一、基本概念

### 1. 普通函数 vs 生成器函数

- **普通函数**：用 `return` 返回一个值，函数执行完就结束。
- **生成器函数**：用 `yield` 产出（yield）一个值，**函数暂停**，下次调用时从暂停处继续执行。

```python
def normal_func():
    return 1

def generator_func():
    yield 1
    yield 2
    yield 3
```

调用 `normal_func()` 直接返回 `1`。  
调用 `generator_func()` **不会立即执行函数体**，而是返回一个 **生成器对象（generator object）**：

```python
gen = generator_func()
print(gen)  # <generator object generator_func at 0x...>
```

要获取值，需要用 `next()` 或遍历：

```python
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
# print(next(gen))  # 抛出 StopIteration 异常
```

或者直接遍历：

```python
for value in generator_func():
    print(value)
# 输出：1 2 3
```

---

## 二、`yield` 的核心特点

### ✅ 1. **暂停与恢复**
- 每次遇到 `yield`，函数暂停，返回值；
- 下次调用时，从 `yield` 的下一行继续执行。

### ✅ 2. **惰性求值（Lazy Evaluation）**
- 值不是一次性生成好，而是**按需生成**；
- 特别适合处理**大数据流**或**无限序列**。

### ✅ 3. **节省内存**
- 不像列表一次性把所有元素存进内存，生成器一次只存一个值。

```python
# 普通列表：占用大量内存（比如100万个整数）
numbers = [x for x in range(1000000)]

# 生成器：几乎不占内存（只在需要时计算）
numbers_gen = (x for x in range(1000000))  # 这是生成器表达式
# 或者
def number_gen():
    for x in range(1000000):
        yield x
```

---

## 三、实际应用场景

### 场景 1：读取大文件（逐行处理）
```python
def read_large_file(file_path):
    with open(file_path, 'r') as f:
        for line in f:
            yield line.strip()

# 使用
for line in read_large_file('huge.log'):
    if 'ERROR' in line:
        print(line)
```
✅ 不会把整个文件读进内存，而是**一行一行处理**。

---

### 场景 2：生成无限序列
```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 取前10个斐波那契数
fib = fibonacci()
for _ in range(10):
    print(next(fib))
```

---

### 场景 3：管道式数据处理（函数链）
```python
def numbers():
    for i in range(10):
        yield i

def square(gen):
    for x in gen:
        yield x * x

def even(gen):
    for x in gen:
        if x % 2 == 0:
            yield x

# 组合使用
result = even(square(numbers()))
print(list(result))  # [0, 4, 16, 36, 64]
```
✅ 每一步都是惰性的，内存开销极小。

---

## 四、`yield` 还可以接收值（高级用法）

生成器不仅能产出值，还能**接收外部传入的值**，通过 `send()` 方法：

```python
def echo():
    while True:
        received = yield
        print(f"收到: {received}")

gen = echo()
next(gen)          # 启动生成器（停在 yield 处）
gen.send("Hello")  # 输出: 收到: Hello
gen.send("World")  # 输出: 收到: World
```

> 这是实现**协程（coroutine）**的基础（在 asyncio 出现前常用）。

---

## 五、常见误区

| 误区                     | 正确理解                                       |
| ------------------------ | ---------------------------------------------- |
| `yield` 和 `return` 一样 | ❌ `yield` 暂停，`return` 结束                  |
| 生成器可以重复使用       | ❌ 生成器是一次性的，用完就空了（除非重新创建） |
| `yield` 只能返回一个值   | ❌ 可以 `yield from` 或多次 `yield`             |

---

## 六、总结

| 特性         | 说明                                     |
| ------------ | ---------------------------------------- |
| **关键字**   | `yield`                                  |
| **作用**     | 将函数变为生成器                         |
| **优点**     | 节省内存、支持惰性计算、可处理无限数据流 |
| **返回值**   | 生成器对象（可迭代）                     |
| **适用场景** | 大数据处理、流式读取、协程、管道式编程   |

> 💡 简单记忆：  
> **`return` 是“一次性交货”，`yield` 是“按需发货，随叫随到”。**

如果你在写爬虫、处理日志、做数据流转换，`yield` 会是你的好帮手！